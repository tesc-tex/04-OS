\subsection{%
  Лекция \texttt{24.??.??}.%
}

\subheader{Мьютексы и семафоры}

На прошлой лекции мы поговорили о том, что существует механизм замк\'a, который
с аппаратной поддержкой решает поставленную задачу. Зачем же тогда нужны
семафоры? Дело в том, что иногда бывает нужно, чтобы не один процесс мог
использовать ресурс, а несколько. Т.е. \(n\) процессов одновременно могут
использовать какой-то ресурс, а \((n + 1)\)-ый уже нет. Вторым примером, когда
требуется более сложный механизм взаимоисключения, чем зам\'oк, является работа
с буфером. Рассмотрим следующую ситуацию:

\begin{center}
  \texttt{command1 | command2}
  
  \texttt{stdout} \(\to\) \texttt{stdin}
\end{center}

Пусть первый процесс посылает байты (по одному), а второй их принимает. Тогда
нам нужно обеспечить синхронизацию этих двух процессов: если первый процесс
записал байт, то пока второй его не считает, первый процесс не должен записывать
следующий байт~--- в противном случае мы просто потеряем информацию. Если же
второй процесс считал байт, то он не должен продолжать считывать, а должен
дождаться, пока первый процесс запишет новый байт. Ясно, что пересылать байты по
одному это неудобно: нам придется много раз переключаться между процессами,
открывать и закрывать замки. Для решения этой проблемы логично использовать
буфер, но тогда возникает три проблемных места. Во-первых, не должно возникать
ситуации, при которой одновременно один процесс пишет, а другой~--- читает. Ведь
запись это не мгновенная ситуация, поэтому может возникнуть проблема, когда
второй процесс считает данные, которые были еще не до конца записаны. Во-вторых,
нам необходимо предотвратить переполнение буфера. В-третьих, мы должны
предотвратить попытку чтения из пустого буфера. Последние две проблемы возникают
из-за того, что планировщик ничего не знает про то, что процессы
\quote{общаются} через буфер, поэтому может возникнуть ситуация, при которой
одному из процессов предоставляется больше времени исполнения, в результате чего
другой процесс либо не успевает считать, либо не успевает записать.

Приведенные примеры объединяет следующее: есть некоторая константа, и пока она
не превышена, то процесс может работать с ресурсом. Если же она превышается, то
процесс должен остановиться. Механизм, который решает эту задачу и называется
семафором. Семафор \(S\) это целая неотрицательная переменная, над которой
разрешены две \textbf{атомарные} операции:

\begin{ccode}
  p(S) { // check
    while (S == 0) blocked;
    S = S - 1;
  }

  v(S) { // increment
    S = S + 1;
  }
\end{ccode}

где под \cinline{blocked} может иметься в виду ожидание (wait), сон (sleep) или
нечто другое. Теперь мы можем написать решение возникшей выше задачи с буфером,
используя семафоры.

\begin{ccode}
  Semaphore mutex = 1;
  Semaphore empty = n; // n is size of buffer
  Semaphore full = 0;
  
  produce() { // process 1
    while (true) {
      ... // produce data
      p(empty);
      p(mutex);
      ... // put data
      v(mutex);
      v(full);
    }
  }

  consume() { // process 2
    while (true) {
      p(full);
      p(mutex);
      ... // read data
      v(mutex);
      v(empty);
      ... // consume data
    }
  }
\end{ccode}

Теперь немного подробнее про семафор с именем \cinline{mutex}. Вообще,
\texttt{mutex} это сокращение от \textbf{mut}ual \textbf{ex}clusion (взаимное
исключение). Тогда замок, который мы рассматривали на прошлой лекции, тоже можно
считать мьютексом. Теоретически это так, но на практике разница заключается в
программно-аппаратной реализации.

\begin{enumerate}
\item
  Spinlock.

  Он похож на код, приведенный в конце прошлой лекции. Это так называемое
  активное ожидание (цикл бездействия), т.е. процесс будет выполнять инструкцию
  \cinline{test_ad_test} до тех пор, пока замок закрыт. Такой подход эффективен
  в случае коротких критических секций.

\item
  Двоичный семафор.

  Эффективен для больших критических секций: процессы, ожидающие открытия
  семафора, (обычно) будут отправляться в непрерываемое ожидание. Тогда
  процессы, вышедшие из этого ожидания, будут получать временное повышение
  приоритета для того, чтобы избежать инверсии приоритетов (ситуации когда
  высокоприоритетный процесс не может исполняться, т.к. нуждается в ресурсе,
  занятым низкоприоритетным процессом).

\item
  Мьютекс.

  Для того, чтобы избежать инверсии приоритетов, также используется наследование
  приоритетов: низкоприоритетный процесс временно получает тот же приоритет, что
  и высокоприоритетный процесс, нуждающийся в ресурсе. Однако для этого нам
  необходимо знать владельца семафора, поэтому он не решает проблему инверсии
  приоритетов. Под мьютексом же сейчас подразумевают двоичный семафор, для
  которого нам известен владелец, т.е. мы не просто знаем, что замок закрыт, но
  также знаем, кто его закрыл.
\end{enumerate}

Здесь мы видим, что задача взаимоисключения частично конфликтует с задачей
планирования: нам приходится повышать приоритет некоторым процессам (хотя с
точки зрения планирования этого не требовалось) для того, чтобы избежать
блокировки.

\subheader{Тупики}

Рассмотрим следующую ситуацию: пусть у нас есть два процесса \(p_0\) и \(p_1\),
которые для своей работы используют ресурсы \(R_1\) и \(R_2\), причем они делают
это так, что критические секции ресурсов пересекаются. Изначально процесс
\(p_0\) занял ресурс \(R_1\), а процесс \(p_1\)~--- ресурс \(R_2\). Спустя
некоторое время (не обязательно одновременно) процессу \(p_0\) потребовался
ресурс \(R_2\), а процессу \(p_1\)~--- ресурс \(R_1\). Процессы встали в тупик:
исполняться дальше они не могут, т.к. им требуются ресурсы друг друга. Отпустить
ресурсы они также не могут, т.к. их критическая секция еще не завершилась. В
итоге они будут бесконечно находиться в состоянии ожидания. Для иллюстрации
проблемы тупиков Дейкстра предложил простой и понятный пример, получивший
название \quote{Проблема обедающих философов}.

Пусть за круглым столом сидит \(5\) философов и перед каждым из них стоит блюдо.
Между соседними философами лежит по одной вилке (итого на столе лежит \(5\)
вилок). Для того, чтобы есть свое блюдо, философу требуются обе вилки, лежащие
непосредственно рядом с ним. Философ может либо есть свое блюдо, либо будучи
сытым находиться в размышлениях, либо будучи голодным ожидать освобождения
вилок.

Если предположить, что процесс еды короткий, а процесс размышлений длинный, при
этом философы становятся голодными в разное время (а не все одновременно), то
никаких особых проблем не возникает. Сложности появляются тогда, когда возникает
состояние борьбы за ресурсы (race condition)~--- в данном случае когда все
философы приблизительно в одно и то же время становятся голодными. Далее у них
есть несколько стратегий.

\subsubheader{I.}{Deadlock}

Пусть алгоритм действий каждого философа будет такой:

\begin{enumerate}
\item
  Дождись освобождения левой вилки и возьми ее.

\item
  Дождись освобождения правой вилки и возьми ее.

\item
  Поешь и отпусти обе вилки.
\end{enumerate}

В этом случае может возникнуть ситуация при которой все философы почти
одновременно возьмут левую вилку, после чего ничего не смогут делать, т.к.
правая для каждого философа вилка будет недоступна, и они будут бесконечно долго
ждать ее освобождения. Это называется deadlock-ом.

\subsubheader{II.}{Livelock}

Пусть алгоритм действий каждого философа будет такой:

\begin{enumerate}
\item
  Дождись освобождения левой вилки и возьми ее.

\item
  Если правая вилка занята, то отпусти левую вилку и после небольшой паузы
  вернись к шагу \(1\).

\item
  Если правая вилка свободна, то возьми ее, поешь и отпусти обе вилки.
\end{enumerate}

В этом случае может возникнуть ситуация при которой все философы почти
одновременно возьмут левую вилку, после чего (т.к. правая для каждого философа
вилка будет занята) также одновременно отпустят ее. А потом снова возьмут и так
далее. В итоге этот процесс теоретически может быть бесконечным. Это называется
livelock-ом, здесь в отличие от deadlock-а процессы что-то делают, но эти
действия непродуктивны (ни один из философов так в итоге и не поест).

\subsubheader{III.}{Рандомизация}

Для того, чтобы избежать проблемы livelock-а, можно попробовать использовать
случайное время ожидания. В целом, это является решением, однако потенциально
возможность возникновения тупика все еще остается (если случайные времена
ожидания окажутся \quote{неудачными}). Также не стоит забывать про накладные
расходы на эту рандомизацию.

\subsubheader{IV.}{\quote{Официант}}

Введем \quote{официанта} (операционную систему), который будет наблюдать за
столом со стороны и контролировать действия философов, запрещая или разрешая им
есть согласно некоторым своим правилам.

\begin{remark}
  На самом деле можно обойтись и без официанта, однако в этом случае необходимо
  разрешить философам \quote{смотреть} на тех, кто сидит рядом с ними. Т.е.
  философ должен принимать решение учитывая состояние своих соседей.
\end{remark}

\subheader{Условия возникновения тупиков}

Для возникновения тупика необходимо \textbf{одновременное} выполнение четырех
условий:

\begin{enumerate}
\item
  Mutual exclusion (взаимоисключение).

  Если ресурс используется одним процессом, то другой процесс не может его
  использовать.

\item
  Hold and wait (ожидание ресурса).

  Если процесс взял ресурс, он имеет право его не отдавать и при этом просить
  какие-либо следующие ресурсы.

\item
  No preemption (неперераспределяемость).
  
  Если мы выделили процессу некоторый ресурс, то мы не может его отобрать:
  процесс может вернуть его только самостоятельно.

\item
  Circular wait (круговое ожидание).

  Процессы встали в круговое ожидание относительно двух или более ресурсов.
\end{enumerate}

\subheader{Методы предотвращения тупиков}

\begin{enumerate}
\item
  Ничего не делать и игнорировать проблему тупиков.

\item
  Пытаться предотвращать тупики. Т.е. организовывать работу ОС таким образом,
  чтобы перечисленные выше \(4\) условия никогда не выполнялись одновременно.

\item
  Обнаружение тупиков и восстановление после тупика. Т.е. мы не предотвращаем
  тупик, но имеет возможность его найти и каким-либо образом исправить.
\end{enumerate}

В рамках данного курса мы не будем рассматривать алгоритмы обнаружения тупиков,
т.к. они весьма трудоемки и носят скорее теоретический характер. Причем в
современных ОС они практически не используются, ведь вероятность возникновения
тупика весьма мала, а вот затраты на его детектирование и исправления довольно
существенны. Современные ОС стараются предотвращать тупики (хотя, как мы узнаем
далее, до конца это сделать невозможно), либо просто их игнорировать: да,
пользователь потенциально может потерять какие-то данные, но это лучше, чем
тратить половину вычислительных мощностей на детектирование и устранение
тупиков. Такие большие затраты возникают в силу того, что в системе сотни
процессов и тысячи ресурсов, поэтому количество возможных колец ожидания
огромно. Можно пытаться находить тупики по странному поведению процессов,
например, если процесс долго не отвечает, то есть подозрение на тупик. Однако
понять, действительно ли там тупик или нет, весьма сложно: проще сказать
пользователю о том, что процесс завис и предложить ему либо завершить его, либо
еще подождать.

Однако лучше все-таки пытаться предотвращать тупики: для этого нам необходимо,
чтобы хотя бы одно из условий возникновения тупика не выполнялось. Сразу стоить
отметить, что универсального решения нет, однако для некоторых частных случаев
такое возможно. Это еще больше сокращает вероятность появления тупика. Что же мы
можем сделать с каждым из условий возникновения тупика?

\begin{enumerate}
\item
  Mutual exclusion.

  В некоторых случаях нам может помочь буферизация. Приведем простой пример с
  принтером: вместо того, чтобы реально печатать на принтере мы будем
  буферизовать данные, посылаемые процессом, и ставить их в очередь. После этого
  мы будем посылать процессу сигнал о том, что данные приняты, и он может
  освободить принтер. А когда уже очередь действительно дойдет до печати этих
  данных, то мы пошлем процессу еще один сигнал (либо о том, что печать успешна,
  либо об ошибке). Такой подход можно применять только тогда, когда нам не очень
  важен первый отклик от ресурса: например, если мы хотим отправлять данные по
  сети, то может возникнуть такая ситуация, что данные не отправятся, а мы уже
  сообщили процессу, что они отправлены, и он их у себя удалил.
  
\item
  Hold and wait.

  Мы можем разрешить процессу при запуске (или когда он в первый раз просит тот
  или иной ресурс) сразу же просить все необходимые ему ресурсы. Стоить помнить,
  что это скорее всего будет неэффективно с точки зрения использования ресурсов,
  поэтому не везде можно использовать такой подход. 

\item
  No preemption.

  Можно разрешить ОС \quote{отбирать} ресурсы у процессов (предварительно
  забуферизовав их контекст, чтобы потом можно было вернуться к этому моменту и
  продолжить исполнение). Однако это не всегда возможно: не у каждого процесса
  можно отобрать ресурс так, чтобы не нарушилась его работа.

\item
  Circular wait.

  Мы можем пронумеровать все процессы и ресурсы. Далее сделаем так, чтобы
  процесс мог брать ресурсы только с номером б\'oльшим, чем у него уже есть.
  Например, если у процесса есть \(1\)-ый и \(3\)-ий ресурсы, то он не может
  взять \(2\)-ой ресурс, но может брать ресурсы с номером \(4\) и больше. Для
  того, чтобы процессы могли получать ресурсы с меньшим номером, мы иногда будем
  перенумеровывать ресурсы по кругу (сдвигая нумерацию на единичку), при этом
  проверяя не приводит ли это к тупику. Проблемы такого решения в накладных
  расходах: во-первых, не очень понятно, как пронумеровать все ресурсы, т.к. они
  появляются и исчезают динамически. Во-вторых, нужно тратить время на
  перерасчеты, сдвиги нумерации, проверки на возможность тупика и т.д.
\end{enumerate}

Напоследок рассмотрим еще один пример взаимодействующих процессов, который
немножко отличается от уже приведенных. Он связан с устройствами ввода-вывода и
с их спецификой в том плане, что из них можно читать и на них можно писать. При
этом во время записи любые другие операции должны быть запрещены (двум процессам
нельзя одновременно писать, а также нельзя одновременно читать и писать). Однако
несколько процессов могут одновременно читать с этих устройств. Разумеется мы
можем сделать так, чтобы с этим ресурсом в один момент времени взаимодействовал
только один процесс. Однако это может быть неэффективно: пусть есть некоторый
ресурс, который часто и много читают, но редко в него пишут. Если все операции
выстроить в очередь, то придется потратить значительно больше времени, чем если
позволять параллельное чтение.

Однако если разрешить параллельное чтение, то может возникнуть проблема,
получившая название \quote{Проблема читателей и писателей}. Ее суть
проиллюстрирована на~\figref{01_10_01}.

\galleryone{01_10_01}{Проблема читателей и писателей}

Таким образом процесс \(p_2\) не может ничего записать из-за того, что процессы
\(p_0\) и \(p_1\) по очереди читают данные. Для того, чтобы этого избежать,
создается единая очередь. Далее ищется первый запрос на запись, и все запросы на
чтение, которые пришли раньше него, распараллеливаются. После окончания их
работы, производится запись, и все повторяется с начала: ищется следующий запрос
на запись, и все чтения до него распараллеливаются.

Такое решение будет плохо себя показывать в случае, если запросы на чтение и
запись чередуются. Чтобы этого избежать, существуют некоторые подходы по
пересортировке очереди так, чтобы стремиться группировать запросы на чтение
(например, создавать группы фиксированного размера). Однако не всегда запросы
можно переставлять местами, поэтому это лишь частное решение.
