\subsection{%
  Лекция \texttt{24.??.??}.%
}

Как уже было сказано на предыдущей лекции, для эффективного использования
ресурсов потребовалось одновременно выполнять (или по крайней мере удерживать в
памяти) несколько программ. Однако количество ядер меньше, чем количество
процессов, которые необходимо исполнять (на тот момент речь шла вообще об
процессорах с одним ядром, которые могут выполнять одновременно только одну
программу). Соответственно, возникает задача об обеспечении разделения времени
процессора. Таким образом, мы сначала даем одной программе (пакету) некоторое
время использовать процессор, потом выполняем переключение (которое тоже
занимает какое-то время) и далее предоставляем ресурс процессора другой
программе. Время, которое мы предоставляем каждой программе, может быть
одинаковым, а может и различаться~--- об этом мы поговорим позже.

Для реализации этих новых механизмов потребовались некоторые дополнительные
вещи. В частности, потребовался таймер, который мог бы вызывать еще один вид
прерываний (до этого существовали только прерывания ввода-вывода). Стоит
отметить, что механизм прерываний по таймеру не так прост: если в результате
обработки этого прерывания было принято решение переключиться на исполнение
другого процесса, то необходимо неким образом сохранить текущее состояние
регистров процессора, чтобы потом иметь возможность вернуться к этому процессу
и продолжить его выполнять.

Однако ЦП это не единственный ресурс. Вторая серьезная задача это обеспечение
разделения памяти, т.к. если несколько программ находятся в памяти одновременно,
то необходимо каким-то образом обеспечить корректную адресацию, ведь на этапе
разработки программного обеспечения нельзя знать, как и где оно будет размещено
в памяти. Решением этой проблемы является виртуализация памяти~--- механизм
виртуальной памяти. Каждая программа внутри себя отсчитывает адреса от
некоторого виртуального нуля, а операционная система предоставляет механизм
пересчета этих виртуальных адресов в физические, причем этот пересчет может
осуществляться как в момент загрузки программы в оперативную память, так и при
каждом обращении (или не при каждом~--- стратегия пересчета может быть и
другой).

Задача обеспечения разделения памяти повлекла за собой задачу обеспечения защиты
программ от деятельности других программ. Для решения этой задачи появляется еще
одно прерывание, которое обеспечивает защиту памяти и прерывает работу
процессора, если происходит попытка обратиться к памяти, принадлежащей другому
приложению. Стоит отметить, что защищать от других программ нужно не только
память, но и другие ресурсы.

Следующей задачей является планирование использования ресурсов и исполнения
программ. Данная задача является более сложной, нежели планирование очереди
пакетов. Помимо этого стоит учитывать, что планирование исполнения программы
тесно связано с планированием ресурсов, которые необходимо выделить этой
программе. Также нужно не забывать про синхронизацию: некоторые ресурсы являются
неразделяемыми, и поэтому нельзя давать к ним доступ поочередно. Например, если
две программы хотят что-то напечатать на принтере, то ЦП нельзя просто
переключаться между ними и печатать по несколько символов от каждой программы.

Еще одной задачей на этапе мультипрограммных операционных систем является задача
обеспечение универсального доступа к устройствам хранения. Для решения этой
задачи появляется файлово-каталожная система и модель прав доступа к разным
файлам и каталогам.

Итого, основные задачи данного этапа:

\begin{enumerate}
\item
  Обеспечение разделения времени процессора.

\item
  Обеспечение разделения памяти.

\item
  Защита программ от действий других программ.

\item
  Планирование выполнения и синхронизация выполнения.

\item
  Обеспечение универсального доступа к устройствам хранения.
\end{enumerate}

Появляется механизм виртуальной машины. Каждое приложение работает как будто на
своей виртуальной версии вычислительного узла и ничего не знает про другие
приложения и про физические ресурсы вычислительного узла. Операционная система
становится тем уровнем абстракции, который разделяет аппаратное обеспечение и
программное обеспечение, позволяя им взаимодействовать только через нее, но не
напрямую. Чтобы поддерживать эту абстракцию требуются некоторые строгие
интерфейсы взаимодействия. Интерфейсом взаимодействия с аппаратным уровнем
становится механизм привилегированного режима (только код ядра операционной
системы имеет доступ к управлению физическими ресурсами вычислительного узла).
В обратную стороны мы получаем механизм прерываний. С точки зрения программного
обеспечения также появляется механизм взаимодействия~--- механизм системных
вызовов (это \quote{просьба} к ядру операционной системы о выполнении некоторой
привилегированной операции или предоставлении некоторого аппаратного ресурса).

Одной из первых операционных систем считается операционная система MCP (1963
год).

\subsubheader{III.}{Сетевые операционные системы}

Узким местом становятся операции ввода-вывода. В связи с развитием качества
связи появляется понятия удаленного терминала и многотерминальности. Теперь
терминал совмещает в себе как функции ввода, так и функции вывода. Из-за
удаленности терминала появляется проблема идентификации: если раньше четко можно
было отследить, кто работает с вычислительным узлом (т.к. для этого необходимо
было физически находится рядом), то теперь сделать это не так просто. Появляется
потребность в дополнительных механизмах идентификации, аутентификации и
авторизации.

Помимо территориального разделения терминалов появляется идея о том, чтобы
каким-то образом связать несколько вычислительных узлов. Эта идея возникла для
того, чтобы разделять выполнение задач между несколькими вычислительными узлами
и не позволять одному из узлов простаивать в то время как другой узел полностью
загружен. Таким образом появляются сетевые операционные системы.

\subheader{IV.}{Универсальные (мобильные открытые) операционные системы}

На данном этапе, т.к. почти под каждый вычислительный узел нужна своя
операционная система, то возникает плохая переносимость: ПО, разработанное для
одной операционной системы, не всегда может работать на другой операционной
системе. Таким образом от операционной системы требуется универсальность, а
значит она должна поддерживать разработку приложений на языке высокого уровня,
что позволит абстрагироваться от прямого доступа к ресурсам. Для того, чтобы это
осуществить, необходимо, чтобы сама операционная система была написана на языке
высокого уровня.

Решение этой проблемы было найдено в 1969 году (Томсон, Керниган и Ритчи). Им
стал язык \texttt{С} и операционная система \texttt{UNICS}. Первая редакция этой
операционной системы пишется на ассемблере и не имеет встроенного компилятора
языка высокого уровня. Одновременно с этим разрабатывается интерпретируемый язык
\texttt{B}, и к 1972 году на этом языке переписывается \texttt{UNICS} (вторая
редакция). Также разрабатывается компилируемый язык \texttt{С}, а код,
написанный на \texttt{B}, постепенно переписывается на \texttt{C}. Итого к 1973
году появляется редакция \texttt{UNICS} с встроенным компилятором \texttt{C}.
Далее, в конце 1973 года, появляется четвертая редакция, в которой ядро
полностью написано на \texttt{С}, а к 1975-ому году и все утилиты также
переписываются на \texttt{С}~--- это и становится пятой редакцией
переименованной операционной системы \texttt{Unix}. Последняя редакция выходит в
1978 году. Далее уже появляются операционные системы называемые \texttt{*nix}
системами в знак того, что они многое унаследовали от \texttt{Unix}.

Одной из систем на основе \texttt{Unix} является \texttt{BSD}, которая в
некотором виде дожила и до наших дней (\texttt{FreeBSD}, \texttt{OpenBSD},
\texttt{NetBSD} и т.д.). На основе \texttt{BSD} была сделана операционная
система \texttt{SunOS}, которая позже станет \texttt{Solaris}, а далее и
\texttt{OpenSolaris}. Также на основе \texttt{Unix} появляются и проприетарные
решения такие как \texttt{HP-UX}, \texttt{AIX}, \texttt{IRIX} и другие. Помимо
этого стоит отметить \texttt{SystemV}, которая появилась как попытка связать
\texttt{Unix}, развивающийся на тот момент \texttt{Solaris} и ветку \texttt{BSD}
решений.

В 1983 году появляется проект \texttt{GNU}. Идея этого проекта заключается в
том, чтобы создать свободное ПО и свободную операционную систему, на которой это
ПО будет работать. Основатель \texttt{GNU} Ричард Столлман выделяет четыре
свободы:

\begin{enumerate}
\item
  Свобода использовать программное обеспечение.

\item
  Свобода изучать и адаптировать программное обеспечение.

\item
  Свобода распространять программное обеспечение.

\item
  Свобода улучшать и публиковать программное обеспечение.
\end{enumerate}

Из последнего пункта вытекает идея copyleft-а. Эта лицензия говорит о том, что
если данное ПО интегрируется в другой проект или модифицируется, то этот проект
также должен иметь copyleft лицензию. Итого все производные проекты и
производные от них проекты также будут свободными (т.е. с copyleft лицензией).

Акроним \texttt{GNU} рекурсивно расшифровывается как Gnu is Not Unix. В рамках
этого проекта создается компилятор \texttt{gcc}, пишутся и переписываются
библиотеки языка \texttt{С}, однако остается проблема с ядром: написать с нуля
ядро новой операционной системы оказывается сложной задачей. В 1991 публикуется
операционная система \texttt{Linux}, которая несмотря на то, что была основана
на операционной системе \texttt{Minix}, обладала собственным, концептуально
новым ядром. Эндрю Таненбаум (автор \texttt{Minix}) высказывает резкую критику в
сторону новой операционной системы, отмечая монолитность ядра и невозможность
переноса на другие архитектуры помимо 8086. Для развития \texttt{Linux} все чаще
начинает использоваться ПО, разработанное в рамках проекта \texttt{GNU}. Таким
образом появляется операционная система, которая сейчас называется
\texttt{GNU/Linux}.

Еще одним примером \texttt{*nix} системы является появившаяся в 1989 году
операционная система \texttt{NeXTSTEP}. В 1997 году она интегрируется вместе с
некоторыми наработками из \texttt{FreeBSD} в проект \texttt{Darwin}, который
позже становится родоначальником операционных систем семейства \texttt{macOS}.
