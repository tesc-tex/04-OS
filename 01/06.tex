\subsection{%
  Лекция \texttt{24.03.13}.%
}

\subheader{Диспетчеризация процессов}

Под диспетчеризацией процессов подразумевается переключение процессов между
различными состояниями. Мы будем рассматривать возможные состояния и переходы
между ними в виде графа (или конечного автомата), где вершинами будут являться
состояния процесса, а ребрами~--- возможные переходы между ними. Сначала
посмотрим на самую простую модель (\figref{01_06_01}).

\galleryone{01_06_01}{Простейший граф состояний процесса}

После создания процесс попадает в состояние ожидания, потом, когда до него
доходит очередь, он начинает выполняться. Далее возможно два варианта: процесс
либо выполнится и завершится, либо снова уйдет в ожидание, причем причины
ожидания могут быть различны. Возможно, процессу потребовался некоторый
неразделяемый ресурс, который сейчас занят, или он был вытеснен более
приоритетным процессом.

Однако у этой модели есть некоторые недостатки. Главным из них является то, что
в состоянии ожидания мы никак не учитываем причину, т.е. чего собственно говоря
ждет процесс. Из-за этого может возникнуть следующая ситуация: мы достали
ожидающий процесс из очереди и начали его исполнять, однако выяснилось, что этот
процесс не дождался того, что ему требовалось, и поэтому сразу же вновь ушел в
ожидание. Переключение с процесса на процесс требует времени, а тут мы сделали
это два раза, да еще и без всякой пользы~--- понятно, что этот момент можно
оптимизировать.

Появляется мысль о том, чтобы использовать различные очереди для процессов,
которые находятся в ожидании какого-либо внешнего события, и для процессов,
которые готовы исполняться, но мы их прервали. На графе состояний и переходов
это отразится следующим образом (\figref{01_06_02}): мы введем новое состояние
\quote{Готов}, в котором будут находиться процессы, готовые к исполнению. В это
же состояние будут попадать только что созданные процессы, т.к. мы предполагаем,
что любой процесс изначально готов к исполнению. Теперь из состояния
\quote{Выполняется} есть два пути: в состояние \quote{Готов} и в состояние
\quote{Ожидает}. Выбор одного из этих путей будет определяться тем, какое именно
событие прервало исполнение этого процесса.

\galleryone{01_06_02}{Трехуровневая модель состояний}

Данная трехуровневая модель состояний реализуется любой операционной системой,
однако даже этих трех уровней может не хватать, тогда в зависимости уже от
специфики операционной системы могут добавляться новые уровни. Здесь стоит
заметить, что порождение процесса это не мгновенная операция: например, в Linux
нужно скопировать уже существующий процесс и поместить код нового процесса в
адресное пространство. Также процессу при создании могут потребоваться некоторые
ресурсы, которые тоже надо получить. Таким образом мы приходим к тому, что
рождение процесса это отдельное состояние, которое также должно быть отражено в
графе состояний (\figref{01_06_03}).

\galleryone{01_06_03}{Новые состояния: \quote{Рождение} и \quote{Завершение}}

По абсолютно аналогичным соображениям мы также добавляем состояние
\quote{Завершение} в граф состояний: например, процесс при завершении отправил
\texttt{SIGCHLD} своему родителю, чтобы тот его обработал. Родительский процесс
может в это время находится в состоянии ожидания, поэтому текущий процесс должен
будет будет дождаться, пока родитель обработает его сигнал. В это время он будет
находиться в состоянии \quote{Завершение}.

В Linux (\textbf{только с точки зрения представления результата пользователю})
состояния \quote{Готов} и \quote{Выполняется} оба обозначаются как
\texttt{running}, т.к. не имеет смысла показывать какой конкретно процесс сейчас
выполняется~--- переключение процессов происходит настолько быстро, что человек
просто не успеет прочитать эту информацию, а процесс уже переключится. А вот
состояние \quote{Ожидает} представлено в двух видах: прерываемое ожидание и
непрерываемое. В случае непрерываемого ожидания у процесса существует конкретная
операция, результат выполнения которой он ждет, и прерывать это ожидание
некорректно с той точки зрения, что это может поменять контекст выполнения, а
это в свою очередь может привести к ошибке. Обращения к такому процессу
необходимо буферизовать и передать их процессу только после завершения ожидания.
Прерываемое ожидание (как понятно из названия) это ожидание, которое может быть
прервано аппаратным прерыванием или сигналом от другого процесса. Оно характерно
для интерактивных процессов, например для веб-серверов.

Также есть еще один момент, характерный для Linux'а (и не только). Допустим, что
процесс в состоянии \quote{Завершение} послал сигнал \texttt{SIGCHLD} своему
родителю, а тот находится в непрерывном ожидании и не выходит из него (но не
завершается). В этом случае текущий процесс спустя некоторое время переходит в
состояние \quote{Зомби} и становится zombie процессом~--- это еще одно состояние
в графе состояний. В это состояние можно попасть единственным образом (описанным
выше) и из него нет выходов.

Необходимо добавить несколько слов про состояние \quote{Завершение}. Оно может
быть как корректным (процесс выполнил свою работу и ему больше нечего делать),
так и аварийным. Обработка аварийных ситуаций чаще всего происходит с помощью
аппаратных прерываний: ядро ловит прерывание, запускает соответствующий
обработчик, который посылает процессу сигнал, чтобы тот мог неким образом
обработать его. Это позволит родительскому процессу узнать код завершения
данного процесса и понять, что пошло не так.

При работе в многопоточном режиме может возникать ситуация рассинхронизации
потоков: допустим, один поток пытается использовать данные, которые должны быть
вычислены другим потоком, однако другой поток еще не успел ничего вычислить (и
мы вручную никак не проконтролировали эту ситуацию). В итоге мы должны перейти
из состояния \quote{Выполняется} в состояние \quote{Завершение} с некоторым
кодом ошибки. Однако если мы попытаемся повторить последнюю операцию через
некоторое время, то второй поток (возможно) успеет провести необходимые
вычисления и ошибки не произойдет. Для обработки таких случаев вводится новое
состояние \quote{Исключетельная ситуация} (\figref{01_06_04})~--- и мы можем
решать сколько попыток давать процессу, прежде чем окончательно отправить его на
завершение.

\galleryone{01_06_04}{Расширенный граф состояний процесса}

Похожим образом вводится состояние \quote{Остановлен}, только если критические
ситуации обрабатывались автоматически, то остановка процесса это обычно
результат действий человека. Допустим, администратор видит, что некоторый
процесс внезапно начал использовать чрезмерно много ресурсов (хотя не должен).
Он может приостановить процесс и разобраться, в чем причина такого поведения,
после чего решить эту проблему и возобновить работу процесса. В Linux для
остановки и возобновления работы процесса используются сигналы \texttt{SIGSTOP}
и \texttt{SIGCONT}.

\subheader{Задача планирования}

Под планированием вычислительного процесса понимается распределение времени
процессора между выполняющимися заданиями или процессами, причем данное
распределение времени должно удовлетворять некоторым критериям (скорость
исполнения, время отклика и т.п.). Из процессов, претендующих на нахождение в
состоянии \quote{Выполняется}, формируется очередь, которой и управляет ОС.
Однако эта очередь не единственная: существуют и другие устройства, к которым
также есть свои очереди. Помимо этого т.к. граф состояний процессов стал
значительно более сложным (\figref{01_06_04}), чем был изначально
(\figref{01_06_01}), то теперь на каждый переход из состояния в состояние также
есть своя очередь. Итого операционная система мало того, что должна управлять
всеми этими очередями, так она еще и должна делать это в совокупности.

Пусть есть некоторое количество процессов, которым необходимо предоставить
какой-либо ресурс. Операционная система некоторым образом выстраивает очередь из
этих процессов, и они начинают исполняться. Однако система открытая: пока
процессы исполняются могут произойти некоторые события, которые приведут к тому,
что изначальный план станет неоптимальным или даже невыполнимым. Допустим, что
для того, чтобы этого избежать, мы будем прерываться после каждого выполненного
процесса и осуществлять перепланирование. Таким образом у нас будет крайне
маленький горизонт планирования: фактически, мы будем планировать лишь на один
шаг вперед. Из плюсов такого решения можно отметить то, что мы будем довольно
точно учитывать все изменения, которые будут происходить в системе, и
следовательно делать выбор весьма оптимально. Однако планирование тоже требует
времени и ресурсов~--- если мы будет так часто его осуществлять, то больше
времени потратим на него, нежели на выполнение реальных процессов. В противовес
такому подходу мы можем иметь большой горизонт планирования, т.е. мы может
составить план на относительно длинный период времени и придерживаться его, не
тратя время на перепланирование. Таким образом мы снижаем накладные расходы на
перепланирование, однако повышается риск (особенно ближе к концу этого плана)
того, что система будет работать не оптимально.

Итого мы имеем ситуацию выбора: у каждого из вариантов есть свои плюсы и минусы,
и нельзя сказать, что один из них однозначно лучше другого в общем случае.
Исходя из этого каждая операционная система (как правило) имеет несколько
планировщиков и разные горизонты планирования: краткосрочное планирование,
среднесрочное планирование и долгосрочное планирование. Еще раз посмотрим на
\figref{01_06_04}. Переход \quote{Готов}~--- \quote{Выполняется} находится в
краткосрочном планировании: здесь используются весьма простые алгоритмы, и даже
если они будут давать не самый оптимальный результат, то ничего страшного не
произойдет, ведь перепланирование будет происходить довольно часто. К
долгосрочному планированию относится переход \quote{Рождение}~--- \quote{Готов},
т.е. принятие решения о самой возможности создания нового процесса, ведь новый
процесс надолго изменит состояние всей системы: он будет требовать ресурсы, его
необходимо будет учитывать в очередях и т.д. Таким образом решение о создании
нового процесса это важное и необратимое решение, поэтому для него требуется
именно долгосрочное планирование.

Пусть у нас есть некоторое количество процессов, которые находятся в прерываемом
ожидании. Мы можем предположить (по каким-либо причинам), что часть из этих
процессов будут находится в этом состоянии еще долго и переместить их данные в
swap, чтобы освободить оперативную память для других процессов. Принятие
подобных решений относится к среднесрочному планированию (на самом деле к
среднему планированию относится не только это). Стоить помнить, что деление на
кратко-, средне- и долгосрочное планирование весьма условно и зависит от
операционной системы. Однако помимо этих трех уровней планирования отдельно
выделяют очереди ввода-вывода, т.к. устройств ввода-вывода может быть несколько.
Этот уровень планирования отличается тем, что если процесс попал в непрерываемое
ожидание, то он встал в очередь к какому-либо устройству, и пока он не выйдет из
этой очереди, то этот процесс можно не учитывать. Контролировать этот выход мы
не можем: это не наше решение, в отличие от среднесрочного планирования, где
именно мы решаем, убирать данные процесса в swap или нет.

\subsubheader{Критерии планирования}{}

\begin{enumerate}
\item
  Критерий справедливости.

  Гарантировать каждому процессу равную долю процессорного времени (или любого
  другого ресурса).

\item
  Критерий эффективности.

  Максимально эффективно использовать все предоставленные ресурсы.

\item
  Критерий сокращения полного времени выполнения.

\item
  Критерий сокращения времени ожидания.

\item
  Критерий сокращения времени отклика.

  Данный критерий важен для интерактивных систем.
\end{enumerate}

\subsubheader{Свойства алгоритмов планирования}{}

\begin{enumerate}
\item
  Алгоритм планирования должен быть предсказуем.

  При многократном запуске на одних и тех же данных мы должны получать
  одинаковый (или достаточно близкий) результат.

\item
  Алгоритм планирования должен иметь минимальные накладные расходы.

\item
  Алгоритм планирования должен быть масштабируемым.
\end{enumerate}
