\subsection{%
  Лекция \texttt{24.??.??}.%
}

\subheader{Эволюция понятия \quote{операционная система}}

\begin{definition}
  Операционная система это базовое системное программное обеспечение,
  управляющее работой вычислительного узла и являющееся посредником между
  аппаратным обеспечением, прикладным программным обеспечением и пользователем.
\end{definition}

Принципы архитектуры фон Неймана:

\begin{enumerate}
\item
  Однородность памяти (и код, и данные находятся в единой памяти).

\item
  Адресность (линейная система адресов) и произвольный доступ к ячейкам памяти.

\item
  Принцип программного управления.

\item
  Принцип кодирования (для всего используется двоичное кодирование).
\end{enumerate}

\subsubheader{I.}{Программы---диспетчеры}

Одной из задач, решаемых на этом этапе, была задача повторного использования
кода, автоматизации загрузки и линковки. Было замечено, что некоторые участки
кода часто повторяются, и чтобы не переписывать их заново, была предложена идея
выделить в оперативной памяти некоторый участок, в который заранее положить
необходимый код, а в основной программе лишь ссылаться на эти функции. В рамках
этой идеи удобно использовать программы, которые подставят нужные адреса
(слинкуют) заготовленные функции в основной программный код. Также необходимо
неким образом обеспечить передачу параметров в эти функции и возможность
взаимодействовать с их результатом. Отсюда и возникла потребность в программном
обеспечении, которое будет автоматически решать эти задачи.

Следующая задача, которая возникла на этом этапе, это задача оптимизации
взаимодействия с устройствами хранения и ввода-вывода. Дело в том, что не всегда
все данные можно сохранить в оперативной памяти, а иногда это просто невыгодно
или ненужно. Таким образом, нужно неким образом подгружать необходимые данные в
оперативную память (из хранилища или с потокового ввода) и выгружать
обработанные данные (в хранилище или в потоковый вывод). На тот момент это можно
было делать только используя центральный процессор, т.к. в противном случае
может возникнуть рассинхронизация: например, операция записи в оперативную
память завершится позже, чем требуется, и попытка работать с этими не до конца
загруженными данными приведет либо к сбою, либо к некорректной обработке этих
данных.

Однако понятно, что это не самый оптимальный способ. Оптимальнее было бы сделать
например так: процессор работает с одним блоком памяти, в то время как другой,
независимый блок оперативной памяти подгружается из хранилища (или
освобождается). Чтобы применить эту идею, введем дополнительно контроллер,
который свяжем и с хранилищем, и с оперативной памятью. Разрешим этому
контроллеру независимо от ЦП заниматься откачкой и подкачкой данных между
хранилищем и оперативной памятью.

Но тогда возникает другая проблема: мы не можем прогнозировать время выполнения
этих операций, т.к. большинство хранилищ используют технологии, которые это не
позволяют. Чтобы решить эту проблему нужно связать (синхронизировать) работу
контроллера и работу центрального процессора. Таким образом появляется механизм
прерываний: сначала ЦП дает управляющую команду контроллеру на закачку
определенного блока данных. По окончании этой операции контроллер инициирует
прерывание, процессор приостанавливает выполнение текущей операции и
обрабатывает это прерывание. В ходе обработки прерывания можно (например)
изменить некоторый флаг, с помощью которого основная программа поймет о том, что
данные готовы к обработке. Данная модель получила название spooling (обеспечение
взаимодействия с периферийным устройством параллельно с работой основного
вычислительного процесса).

\begin{definition}
  Прерывание это сигнал, поступающий от внешнего устройства к центральному
  процессору, сообщающий о наступлении некоторого события, в результате которого
  процессор приостанавливает выполнение текущего набора команд и передает
  управление подпрограмме~--- обработчику прерывания.
\end{definition}

Последняя задача в рамках этапа программ---диспетчеров это появление
однопрограммной пакетной обработки. Т.к. программы становились больше и иногда
возникала потребность в том, чтобы переиспользовать некоторые специфичные части
кода, то появилось разделение на пакеты. Теперь в память загружалась не просто
программа, а некоторое количество пакетов: пока один пакет выполнялся, другой
пакет (или несколько пакетов) подгружались в память. Появляется понятие очереди
из пакетов, и возникает необходимость в управлении этой очередью: например,
некоторые пакеты по тем или иным причинам должны получить приоритет.

Итого, задачи решаемые на данном этапе:

\begin{enumerate}
\item
  Задача повторного использования кода, автоматизации загрузки и линковки.

\item
  Задача оптимизации взаимодействия с устройствами хранения и ввода-вывода.

\item
  Задача однопрограммной пакетной обработки.  
\end{enumerate}

\subsubheader{II.}{Мультипрограммные операционные системы}

Разные программы имеют разные требования к ЦП и к контроллеру: есть программы,
которые используют много памяти, но мало процессорного времени, а есть
программы, которые наоборот, требуют мало памяти, но сильно нагружают процессор.
Однако вычислительный узел должен быть универсален и не должен подстраиваться
лишь под одну задачу. Итого получается, что в зависимости от текущей программы
либо процессор, либо контроллер будет простаивать. Это неэффективно, из-за чего
появляется идея сделать так, чтобы пока одна программа использует ресурсы ЦП,
другая могла бы использовать контроллер, чтобы погрузить необходимые ей данные в
оперативную память. Таким образом ни ЦП, ни контроллер не будут простаивать
впустую, а эффективность работы узла будет определяться тем, сколько программ
одновременно смогут использовать необходимые им ресурсы.

Однако такой подход влечет за собой массу проблем: если раньше была единая
очередь и порядок выполнения команд был очевиден, то теперь необходимо
переключаться между программами, следить за тем, чтобы программы не использовали
чужие участки памяти, организовывать работу с хранилищем, следить за уровнем
доступа к ресурсам и так далее. Решением этих проблем является операционная
система, которая занимает позицию между аппаратным обеспечением, программным
обеспечением и пользователями.
