\subsection{%
  Лекция \texttt{24.??.??}.%
}

\subheader{Системная архитектура}

Т.к. требования, предъявляемые к операционной системе, противоречивы и
операционная система является открытой системой, то в области операционных
систем нет \quote{идеального} решения, которое бы удовлетворило всем
требованиям~--- всегда приходится искать компромисс. Исходя из этого существуют
разные архитектурные решения, имеющие разные преимущества и недостатки. Главным
моментом, определяющим архитектуру ОС, является ответ на вопрос: что и как будет
выполняться в ядре, а что будет вынесено за его пределы.

\begin{definition}
  Ядром операционной системы называется та часть ее кода, которая отличается
  двумя характеристиками присущими только ей (в совокупности) и никому больше:
  резидентность и привилегированный режим. Причем если резидентность может быть
  присуща другому ПО, то привилегированный режим это характеристики только ядра
  операционной системы.
\end{definition}

\begin{definition}
  Резидентность ядра означает то, что его код находится в оперативной памяти
  всегда, в течении всего периода эксплуатации операционной системы, и как
  правило в неизменных адресах.
\end{definition}

\begin{definition}
  Код, выполняемый в привилегированном режиме, не ограничивается проверками на
  доступ к адресам памяти.   
\end{definition}

Таким образом с одной стороны хочется, чтобы код ядра был как можно меньше: так
он будет требовать меньше оперативной памяти, а также повысится надежность, ведь
чем больше кода имеет доступ к привилегированному режиму, тем больше вероятность
возникновения ошибки, а ошибка на таком уровне будет стоить очень дорого. С
другой стороны встает вопрос безопасности: чем меньше будет ядро, тем больше
функций придется выполнять вне привилегированного режима, а значит придется
переключаться между режимами, чтобы обеспечить взаимодействие компонентов ОС.
Если же б\'oльшая часть компонентов ОС помещена в ядро, то они могут
взаимодействовать между собой напрямую, что увеличивает быстродействие системы.
Помимо этого чем меньше код ядра, тем больше существует возможностей вмешаться в
работу той части ОС, которая не защищена привилегированным режимом.

Помимо ядра существуют и другие принципы, которые влияют на архитектуру
операционных систем:

\begin{enumerate}
\item
  Принцип модульной организации.

  Операционная система, как и любое сложное ПО, должна быть представлена в виде
  совокупности модулей с изолированной функциональностью.

\item
  Принцип функциональной избыточности.

  Операционная система должна обладать функционалом б\'oльшим, чем нужно каждому
  конкретному пользователю здесь и сейчас.

\item
  Принцип функциональной избирательности.

  Архитектура операционной системы должна позволять нам выбирать между
  функциями, предоставляемыми этой ОС. Причем должна быть возможность делать
  выбор на разных уровнях: например, какую-то функцию можно временно отключить,
  чтобы не расходовать на нее ресурсы, а какую-то функциональность можно
  получить, если поставить дополнительный пакет.

\item
  Принцип параметрической универсальности.

  Операционная система должна выносить во внешнюю среду как можно больше своих
  параметров управления.

\item
  Концепция многоуровневой иерархической вычислительной системы.

  Операционная система обычно делится на слои, и, обеспечив интерфейс
  взаимодействия между слоями, мы получаем возможность изменять один из слоев,
  не затрагивая остальные.

\item
  Принцип разделения модулей операционной системы.

  Модули операционной системы делятся на модули ядра и модули, относящиеся к
  вспомогательным функциям.
\end{enumerate}

\subheader{Архитектуры операционных систем}

\subsubheader{I.a}{Монолитная архитектура}

Несмотря на название в монолитной архитектуре можно выделить три слоя (не всегда
явно, но обычно это так): главная программа, сервисы и утилиты. Главная
программа представлена одним модулем и умеет взаимодействовать с сервисами, а
сервисы уже взаимодействуют с утилитами по принципу \quote{многие-ко-многим},
т.е. один сервис может взаимодействовать с несколькими утилитами и одна утилита
может использоваться несколькими сервисами. Для чего же нужно такое разделение?

Утилиты обеспечивают нам работу с аппаратной частью, каждая их них реализует
некоторый протокол взаимодействия с контроллером соответствующего экземпляра
аппаратного обеспечения. Главная программа же является интерфейсом для
взаимодействия с пользовательским ПО~--- ее задачей является получение системных
вызовов. Механизм системных вызовов работает следующим образом: программа
помещает в некоторой (но не произвольной) части выделенной ей памяти
идентификатор системного вызова и необходимые аргументы и инициирует программное
прерывание. Далее управление передается ядру операционной системы (в данном
случае слою главной программы) и происходит анализ: какая программа инициировала
системный вызов, какие аргументы были переданы и т.д. Из-за того, что утилиты
работают с аппаратной частью, то существует еще слой сервисов, которые умеют
принимать решения и исполнять их с помощью утилит. Главная программа после
\quote{расшифровки} системного вызова вызывает один или несколько сервисов,
которые уже непосредственно занимаются его выполнением. Результат работы сервиса
передается сначала главной программе, а потом и инициировавшему системный вызов
приложению.

К преимуществам этой архитектуры относится быстродействие (сервисы могут
вызывать утилиты без переключения режима), безопасность (все решения принимаются
на уровне ядра). Из недостатков можно отметить проблемы с надежностью и
повышенные затраты памяти.

\subsubheader{I.b}{Многослойная архитектура}

Со временем из-за большего количества функций, возложенных на операционную
систему, количество сервисов довольно сильно увеличилось и появилась идея о
разделении среднего слоя сервисов на несколько. Это концепция многослойной
архитектуры. \textbf{Нельзя считать, что это новая отдельная архитектура} (т.к.
даже в рамках монолитной архитектуры можно выделить слои): это скорее концепция,
которая является логическим продолжением монолитной архитектуры и далее позволит
нам перейти к другим видам архитектур. Причем стоит отметить, что многослойную
архитектуру строили по-разному, и она менялась с течением времени. Далее будет
рассмотрен лишь один из вариантов ее трактовки.

Данную архитектуру удобно представить в виде концентрических окружностей. Тогда
если смотреть от центра наружу, то порядок слоев будет такой:

\begin{enumerate}
\item
  Аппаратное обеспечение.  

\item
  Средства аппаратной поддержки ядра.
  
  \begin{enumerate}
  \item
    Система прерываний.

  \item
    Средство для поддержки привилегированного режима.

  \item
    Средство поддержки виртуальной памяти.

  \item
    Смена контекстовых регистров.

  \item
    Системный таймер.

  \item
    Защита памяти.
  \end{enumerate}

\item
  Машинно-зависимые модули (hardware abstraction layer, HAL).

\item
  Базовые механизмы ядра.

  Этот слой отвечает за исполнение решений, принятых менеджерами ресурсов.

\item
  Менеджеры ресурсов.

  На этом слое реализованы основные алгоритмы принятия решений: модули для
  составления расписаний (schedulers) и модули, занимающиеся задачами размещения
  (allocators).

\item
  Интерфейс системных вызовов (API).
\end{enumerate}

Стоит отметить, что первые два внутренних слоя реализованы на аппаратном уровне.
Слои 2 и 3 (их имеет смысл рассматривать в паре) обеспечивают возможность
установки ОС на ту или иную платформу.

\begin{remark}
  Если все вышеперечисленные слои относятся к ядру, то такая архитектура все еще
  будет называться монолитной.
\end{remark}

Еще одним серьезным монолитного ядра является то, что при любом изменении
аппаратного обеспечения (и не только его) требуется перекомпиляция ядра. Даже
когда появились решения, требующие не пересборки ядра, а лишь перезапуска ОС,
это проблема все осталась актуальной: например, если ОС развернута на сервере,
то ее перезапуск приведет к тому, что пользователи некоторое время не будут
иметь доступа к серверу (что не всегда допустимо).

Развитием монолитного ядра стало модульное ядро. Его преимуществом является то,
что зачастую (но не всегда) можно добавить, удалить или заменить модуль без
перезапуска ядра.

Также недостатком монолитного ядра являются проблемы с созданием распределенных
решений. Пусть есть несколько физических вычислительных узлов и требуется
балансировать нагрузку между ними. В случае монолитной архитектуры у каждого
узла будут свои менеджеры ресурсов и, следовательно, будет очень сложно этого
достичь.

\subsubheader{II.}{Микроядерная архитектура}

Идея заключается в том, чтобы взять многослойную архитектуру и часть внешних
слоев вынеси из режима ядра (kernel mode) в пользовательский режим (user mode).
В режиме ядра остается слой базовых механизмов и более внутренние слои, т.е.
слои, отвечающие за непосредственное исполнение решений, а вот слои, принимающие
решения, переходят в пользовательский режим. Если в многослойной архитектуре
решения принимали менеджеры ресурсов, то в микроядерной архитектуре это делают
серверы (суть та же, но название другое). Теперь если приложению нужно совершить
системный вызов, то оно сначала обращается в ядро, ядро отдает запрос
соответствующему серверу (или нескольким), возвращаясь в пользовательский режим.
После выполнения запроса сервер отвечает ядру, а оно передает этот ответ
приложению, которое изначально инициировало системный вызов.

Основным преимуществом является то, что мы уменьшаем объемы памяти, выделяемые
для операционной системы. Другим преимуществом является удобство в построении
распределенных систем. К недостаткам можно отнести количество переключений между
режимами, однако это не главная проблема. Основной проблемой является надежность
и безопасность: т.к. серверы находятся в пользовательском режиме, то другое
пользовательское ПО может помешать их работе или перехватить какие-либо данные.

\begin{remark}
  Гибридное ядро это то ядро, которое можно пересобрать так, что часть функций
  поменяет свое расположение (перейдет из режима ядра в пользовательский режим
  или наоборот). 
\end{remark}

\subsubheader{III.}{Наноядерная архитектура}

Идея наноядерной архитектуры заключается в том, чтобы взять микроядерную
архитектуру и еще больше функций вынеси из ядра. Как правило при этой
архитектуре в ядре остается только обработка прерываний, но иногда там
дополнительно реализуются низкоуровневые планировщики с простым алгоритмом
планирования. Наноядра в основном используют в гипервизорах для систем
виртуализации.

\subsubheader{IV.}{Экзоядерная архитектура}

Данная архитектура является развитием идеи распределенной ОС и попыткой
построить гетерогенную (т.е. реализованную над разнородным оборудованием)
распределенную ОС. В данной архитектуре принятие решений и межпроцессное
взаимодействие остаются в режиме ядра, а взаимодействие с оборудованием
разрешается напрямую.
