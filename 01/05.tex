\subsection{%
Лекция \texttt{24.??.??}.%
}

\subheader{Управление процессами}

\begin{definition}
  Процесс это совокупность набора исполняющихся команд, ассоциированных с ним
  ресурсов и контекста исполнения, находящихся под управлением операционной
  системы.
\end{definition}

Процесс для операционной системы представлен в виде некоторой структуры данных
(process control block (PCB), дескриптор процесса). Стоит отметить, что процесс
это не то же самое, что и программа: одна программа может порождать несколько
процессов. Это весьма логичный и понятный вариант: допустим в некотором
комплексном ПО один процесс занимается обработкой GUI, а другой взаимодействием
по сети. Однако обратная ситуация также возможна: несколько программ могут
исполняться в рамках одного процесса. Допустим, мы запустили некоторое
приложение, и оно выполнило системный вызов. Тогда часть времени в рамках одного
процесса выполнялся непосредственно код приложения, а часть времени~--- код
ядра. Т.к. ядро это отдельная программа (даже скорее несколько программ), то
получается, что в рамках одного процесса выполнялось несколько программ.

Однако одного понятия процесса недостаточно для эффективного манипулирования
ресурсами. Предположим, что у нас есть большая растровая картинка, которую надо
каким-либо образом обработать, причем обработка каждого конкретного пикселя
может происходить независимо от обработки других пикселей. В этом случае
эффективно обрабатывать данную картинку параллельно и по частям, однако
концепция процессов мешает этому: картинка должна быть помещена в адресное
пространство только одного процесса, а другие процессы не должны иметь к ней
доступ. Для решения этой проблемы появилась следующая идея: пусть внутри одного
процесса будет разрешено создавать несколько наборов команд и связанных с ними
контекстов.

\begin{definition}
  Пара из набора команд и связанного с ним контекста в рамках одного процесса
  называется потоком (thread).
\end{definition}

Итого в рамках одного процесса может существовать несколько потоков, причем все
потоки имеют доступ в общему адресному пространству процесса. Стоит отметить,
что в современных ОС единицей диспетчеризации является именно поток, а не
процесс. Однако в связи в этим возникают некоторые проблемы, а именно:
переключение между потоками возможно только через переключение в режим ядра,
т.к. диспетчеризацией потоков занимается ОС (и делает она это в режиме ядра).
Причем т.к. за переключение потоков отвечает ОС, то она может делать это не так,
как задумано разработчиком ПО. Это в свою очередь может негативно сказаться на
производительности.

Для решения этой проблемы появился еще один уровень иерархии (ниже потоков),
который называется волокно (fiber) и предоставляет пользовательскую
многопоточность вне инструментария ОС. Теперь любой поток представлен в виде
множества волокон.

\begin{remark}
  Существуют разночтения в термине fiber. Помимо \quote{волокна} он иногда
  трактуется как \quote{легковесный поток}, а иногда как \quote{green thread}
  (зеленый поток).
\end{remark}

Как и в случае потока, каждое волокно содержит в себе некоторый набор команд и
контекст их выполнения, но разница в том, что управление переключением между
волокнами (и его планирование) берет на себя код этого потока, а не ОС. Плюсами
такого подхода является решение проблем, описанных выше, а вот к минусам можно
отнести то, что приходится самостоятельно реализовывать алгоритмы планирования и
переключения между волокнами.

У операционной системы есть механизм прерываний по таймеру, который позволит
переключать потоки, а у волокон нет такого механизма. Основным решением этой
проблемы стало решение кооперативной многозадачности: его идея заключается в
том, что само волокно в какой-то момент отдаст управление следующему волокну,
либо волокну, являющемуся диспетчером. Также стоит отметить, что у волокон может
быть поддержка на уровне ОС: не с точки зрения планирования, а точки зрения
предоставления API для разработки приложений с использованием этого механизма.

Однако даже этих трех уровней иерархии оказалось недостаточно, чтобы эффективно
управлять процессами в операционной системе. Представим себе работу браузера:
если для каждой вкладки сделать отдельный поток, то возникнет проблема с
безопасностью. Т.к. потоки в рамках процесса браузера имеют общее адресное
пространство, то одна вкладка будет иметь возможность получить доступ к данным
другой вкладки (причем это может быть как преднамеренно, так и вследствие
некоторой ошибки). Отсюда возникает другая идея: выстроим иерархию процессов,
где будет корневой процесс, а все вкладки будут им порождены. Но тогда возникает
следующая проблема: пусть мы открыли какое-то одно приложение и \(99\) вкладок в
браузере, тогда с точки зрения операционной системы \(99\%\) процессов это
процессы браузера и лишь \(1\%\) это процессы другого приложения. Однако
планировщик учитывает их всех на одном уровне.

Отсюда возникает идея о том, что нужно научиться ограничивать доступ к ресурсам
для некоторых групп процессов. Для этого в иерархии над процессами появляется
еще один уровень. В разных операционных системах он называется по-разному: в
Windows это job (задание, работа), в Linux это cgroup (контрольная группа). Суть
заключается в том, что в рамках этой группы процессов можно установить
определенные квоты на использование тех или иных ресурсов.

\subheader{Основные функции подсистемы управления процессами}

\begin{enumerate}
\item
  Создание.
  
  В операционной системе любой процесс порождается другим процессом, он не
  создается абстрактно извне. Таким образом любой процесс имеет родительский
  процесс. Как именно появляется первый процесс мы не будем рассматривать в
  рамках этого курса, лишь скажем что какое-то решение есть, и он как-то
  появляется. Отсюда получается, что в операционной системе есть некоторая
  иерархия процессов (и в разных ОС она будет отличаться), где каждый процесс
  представлен некоторой структурой данных. В разных ОС она будет разной, но в
  общем виде эта структура содержит следующие поля:
  
  \begin{enumerate}
  \item
    Информация по идентификации процесса. Сюда входят PID (уникальный
    идентификатор процесса), PPID (идентификатор родительского процесса), UID
    (идентификатор пользователя, запустившего процесс).
    
  \item
    Информация по состоянию процесса (статус и контекст).
    
  \item
    История (она сильно зависит не только от типа ОС, но и от ее версии и
    планировщика).
  \end{enumerate}
  
  Как же создается процесс? Сначала рассмотрим пользовательские процессы в Linux
  (процессы ядра рассматривать не будем). Они образуют дерево процессов, где
  корнем является процесс с PID \(= 1\) и PPID \(= 0\). Порождение новых
  процессов происходит методом клонирования (fork), т.е. полным копированием
  адресного пространства. PID для нового процесса выдается ОС, PPID определяется
  как PID процесса, который клонировали, а другие свойства (например UID)
  наследуются от родительского процесса. Таким образом ни один дочерний процесс
  не будет иметь больше прав, чем его родитель, что выгодно с точки зрения
  безопасности.

  После клонирования сегмент кода дочернего процесса заменяется на код
  необходимого приложения, и мы получаем полноценный новый процесс. После
  завершения работы дочерний процесс \quote{отчитывается} родителю об этом, и
  родитель (с помощью системного вызова) может считать и обработать код его
  завершения. Если же родительский процесс внезапно нештатно завершается (а его
  дочерние процессы продолжают работать), то новым родителем для
  \quote{осиротевших} процессов становится корневой процесс, т.к. дерево
  процессов должно оставаться связным. Есть так же и другая интересная ситуация:
  если родительский продолжает работать, но не может корректно обработать код
  завершения дочернего процесса, то такой дочерний процесс становится
  \quote{зомби}-процессом. Он вроде бы и завершил свою работу, но все равно
  остается в дереве процессов. Подробнее об этом будет рассказано в следующей
  лекции.

  В Windows работает другой механизм. Корневым процессом является диспетчер
  процессов, который несет ответственность за создание всех новых процессов, т.е.
  если какому-либо из процессов потребовалось создать потомка, то он через
  системный вызов обращается к диспетчеру процессов и просит создать новый
  процесс. Таким образом нет никакого дерева процессов: все процессы как бы
  являются потомками диспетчера процессов. Плюсом такого решения является
  централизованный тотальный контроль за появлением процессов. С другой стороны
  права дочернего процесса определяются не родительским процессом, а диспетчером
  процессов, поэтому формально можно создать процесс с правами выше, чем у
  родительского процесса. Для предотвращения этого у ОС есть механизмы защиты,
  но потенциальная возможность их обойти все равно остается.

\item
  Обеспечение ресурсами.

  Любой процесс с самого начала уже обеспечен некоторыми ресурсами: например,
  ему выделено адресное пространство. Такие ресурсы называются статическими и
  будут оставаться с процессом до его завершения. Однако есть еще и динамические
  ресурсы: например, в процессе своего выполнения процесс может потребовать
  дополнительную память или доступ к файлу. Даже процессорное время тоже можно
  считать динамическим ресурсом. Итого задача обеспечения ресурсами сводится к
  задачам планирования ресурсов (задача о расписании) и аллокации (задача о
  рюкзаке).

\item
  Изоляция.

  В последующих лекциях про память будет обсуждаться вопрос об обеспечении
  изоляции памяти. Также в последующих лекциях при обсуждении синхронизации
  частично будет затронута тема изоляции.

\item
  Планирование.

  Планированию далее будет посвящена отдельная лекция, т.к. это весьма
  многоуровневый процесс: необходимо планировать процессорное время, очереди на
  ввод-вывод, рождаемость процессов и т.д.

\item
  Диспетчеризация (переключение процесса между различными состояниями).

  Простейшая диспетчеризация заключается в том, что процесс переключается между
  состояниями \quote{работает} и \quote{ждет}. Смена состояний происходит в три
  шага:

  \begin{enumerate}
  \item
    Сохранение контекста текущего процесса.

  \item
    Загрузка контекст другого процесса.

  \item
    Смена состояний этих двух процессов.
  \end{enumerate}

  Стоит отметить, что последний шаг должен быть атомарным, в противном случае
  мы получаем неуправляемое состояние системы: если произойдет прерывание, то
  у нас одновременно будет существовать либо два работающих процесса, либо
  вообще ни одного. Для удовлетворения этого требования существуют разные хитрые
  механизмы, которые будут рассмотрены позднее. Понятно, что у процесса может
  быть больше двух состояний: об этих состояниях и о переходах между ними мы
  поговорим на следующей лекции.

\item
  Взаимодействие.

  В рамках этого курса будем касаться этой темы достаточно слабо, т.к.
  взаимодействие процессов существенно отличается в разных операционных
  системах.

\item
  Синхронизация.

  Этой теме также будет посвящена отдельная лекция (даже чуть больше), в рамках
  которой мы поговорим про семафоры, мьютексы, тупики и т.п.

\item
  Уничтожение.

  Уничтожение процесса это не такой простой процесс, как кажется на первый
  взгляд: процесс мог владеть определенными ресурсами, которые возможно нужно
  корректно \quote{завершить}. Например, процесс что-то записал в файл, но т.к.
  современные файловые системы чаще всего используют механизм отложенной записи,
  то ОС нужно принудительно инициировать запись на диск, ведь после уничтожения
  процесса данные, которые он хотел записать, станут недоступны. Также может
  быть такое, что процесс владел некоторыми неразделяемыми ресурсами и
  блокировал доступ к этим ресурсам для других процессов~--- после уничтожения
  эти блокировки нужно снять.

  Помимо этого необходимо завершить все дочерние процессы: проверить, что они
  корректно завершились, и в противном случае каким-либо образом это обработать.
  Еще нужно отчитаться родительскому процессу о своем завершении и предоставить
  код завершения.
\end{enumerate}
